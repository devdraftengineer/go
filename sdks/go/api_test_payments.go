/*
Devdraft AI Payment & Business Management API

 A comprehensive payment processing and business management API that enables seamless integration of cryptocurrency and traditional payment methods.     

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package devdraft

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TestPaymentsAPIService TestPaymentsAPI service
type TestPaymentsAPIService service

type ApiTestPaymentControllerCreatePaymentV0Request struct {
	ctx context.Context
	ApiService *TestPaymentsAPIService
	idempotencyKey *string
	paymentRequestDto *PaymentRequestDto
}

// Unique key to ensure the request is idempotent. If a request with the same key is sent multiple times, only the first will be processed, and subsequent requests will return the same response.
func (r ApiTestPaymentControllerCreatePaymentV0Request) IdempotencyKey(idempotencyKey string) ApiTestPaymentControllerCreatePaymentV0Request {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiTestPaymentControllerCreatePaymentV0Request) PaymentRequestDto(paymentRequestDto PaymentRequestDto) ApiTestPaymentControllerCreatePaymentV0Request {
	r.paymentRequestDto = &paymentRequestDto
	return r
}

func (r ApiTestPaymentControllerCreatePaymentV0Request) Execute() (*PaymentResponseDto, *http.Response, error) {
	return r.ApiService.TestPaymentControllerCreatePaymentV0Execute(r)
}

/*
TestPaymentControllerCreatePaymentV0 Process a test payment

Creates a new payment. Requires an idempotency key to prevent duplicate payments on retry.
    
## Idempotency Key Best Practices

1. **Generate unique keys**: Use UUIDs or similar unique identifiers, prefixed with a descriptive operation name
2. **Store keys client-side**: Save the key with the original request so you can retry with the same key
3. **Key format**: Between 6-64 alphanumeric characters
4. **Expiration**: Keys expire after 24 hours by default
5. **Use case**: Perfect for ensuring payment operations are never processed twice, even during network failures

## Example Request (curl)

```bash
curl -X POST \
  https://api.example.com/rest-api/v0/test-payment \
  -H 'Content-Type: application/json' \
  -H 'Client-Key: your-api-key' \
  -H 'Client-Secret: your-api-secret' \
  -H 'Idempotency-Key: payment_123456_unique_key' \
  -d '{
    "amount": 100.00,
    "currency": "USD",
    "description": "Test payment for order #12345",
    "customerId": "cus_12345"
  }'
```

## Example Response (First Request)

```json
{
  "id": "pay_abc123xyz456",
  "amount": 100.00,
  "currency": "USD",
  "status": "succeeded",
  "timestamp": "2023-07-01T12:00:00.000Z"
}
```

## Example Response (Duplicate Request)

The exact same response will be returned for any duplicate request with the same idempotency key, without creating a new payment.

## Retry Scenario Example

Network failure during payment submission:
1. Client creates payment request with idempotency key: "payment_123456_unique_key"
2. Request begins processing, but network connection fails before response received
3. Client retries the exact same request with the same idempotency key
4. Server detects duplicate idempotency key and returns the result of the first request
5. No duplicate payment is created

If you retry with same key but different parameters (e.g., different amount), you'll receive a 409 Conflict error.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestPaymentControllerCreatePaymentV0Request
*/
func (a *TestPaymentsAPIService) TestPaymentControllerCreatePaymentV0(ctx context.Context) ApiTestPaymentControllerCreatePaymentV0Request {
	return ApiTestPaymentControllerCreatePaymentV0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PaymentResponseDto
func (a *TestPaymentsAPIService) TestPaymentControllerCreatePaymentV0Execute(r ApiTestPaymentControllerCreatePaymentV0Request) (*PaymentResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestPaymentsAPIService.TestPaymentControllerCreatePaymentV0")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v0/test-payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.paymentRequestDto == nil {
		return localVarReturnValue, nil, reportError("paymentRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-key", r.idempotencyKey, "simple", "")
	// body params
	localVarPostBody = r.paymentRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-secret"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-secret"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestPaymentControllerGetPaymentV0Request struct {
	ctx context.Context
	ApiService *TestPaymentsAPIService
	id string
}

func (r ApiTestPaymentControllerGetPaymentV0Request) Execute() (*PaymentResponseDto, *http.Response, error) {
	return r.ApiService.TestPaymentControllerGetPaymentV0Execute(r)
}

/*
TestPaymentControllerGetPaymentV0 Get payment details by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Payment ID
 @return ApiTestPaymentControllerGetPaymentV0Request
*/
func (a *TestPaymentsAPIService) TestPaymentControllerGetPaymentV0(ctx context.Context, id string) ApiTestPaymentControllerGetPaymentV0Request {
	return ApiTestPaymentControllerGetPaymentV0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PaymentResponseDto
func (a *TestPaymentsAPIService) TestPaymentControllerGetPaymentV0Execute(r ApiTestPaymentControllerGetPaymentV0Request) (*PaymentResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaymentResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestPaymentsAPIService.TestPaymentControllerGetPaymentV0")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v0/test-payment/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-secret"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-secret"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestPaymentControllerRefundPaymentV0Request struct {
	ctx context.Context
	ApiService *TestPaymentsAPIService
	id string
	idempotencyKey *string
}

// Unique key to ensure the refund request is idempotent. If a request with the same key is sent multiple times, only the first will be processed, and subsequent requests will return the same response.
func (r ApiTestPaymentControllerRefundPaymentV0Request) IdempotencyKey(idempotencyKey string) ApiTestPaymentControllerRefundPaymentV0Request {
	r.idempotencyKey = &idempotencyKey
	return r
}

func (r ApiTestPaymentControllerRefundPaymentV0Request) Execute() (*RefundResponseDto, *http.Response, error) {
	return r.ApiService.TestPaymentControllerRefundPaymentV0Execute(r)
}

/*
TestPaymentControllerRefundPaymentV0 Refund a payment

Refunds an existing payment. Requires an idempotency key to prevent duplicate refunds on retry.
    
## Idempotency Key Benefits for Refunds

Refunds are critical financial operations where duplicates can cause serious issues. Using idempotency keys ensures:

1. **Prevent duplicate refunds**: Even if a request times out or fails, retrying with the same key won't issue multiple refunds
2. **Safe retries**: Network failures or timeouts won't risk creating multiple refunds
3. **Consistent response**: Always get the same response for the same operation

## Example Request (curl)

```bash
curl -X POST \
  https://api.example.com/rest-api/v0/test-payment/pay_abc123xyz456/refund \
  -H 'Content-Type: application/json' \
  -H 'Client-Key: your-api-key' \
  -H 'Client-Secret: your-api-secret' \
  -H 'Idempotency-Key: refund_123456_unique_key'
```

## Example Response (First Request)

```json
{
  "id": "ref_xyz789",
  "paymentId": "pay_abc123xyz456",
  "amount": 100.00,
  "status": "succeeded",
  "timestamp": "2023-07-01T14:30:00.000Z"
}
```

## Example Response (Duplicate Request)

The exact same response will be returned for any duplicate request with the same idempotency key, without creating a new refund.

## Idempotency Key Guidelines

- Use a unique key for each distinct refund operation
- Store keys client-side to ensure you can retry with the same key if needed
- Keys expire after 24 hours by default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Payment ID to refund
 @return ApiTestPaymentControllerRefundPaymentV0Request
*/
func (a *TestPaymentsAPIService) TestPaymentControllerRefundPaymentV0(ctx context.Context, id string) ApiTestPaymentControllerRefundPaymentV0Request {
	return ApiTestPaymentControllerRefundPaymentV0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RefundResponseDto
func (a *TestPaymentsAPIService) TestPaymentControllerRefundPaymentV0Execute(r ApiTestPaymentControllerRefundPaymentV0Request) (*RefundResponseDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RefundResponseDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TestPaymentsAPIService.TestPaymentControllerRefundPaymentV0")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v0/test-payment/{id}/refund"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return localVarReturnValue, nil, reportError("idempotencyKey is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-key", r.idempotencyKey, "simple", "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-secret"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-secret"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
