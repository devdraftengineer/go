/*
Devdraft AI Payment & Business Management API

 A comprehensive payment processing and business management API that enables seamless integration of cryptocurrency and traditional payment methods.     

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package devdraft

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// PaymentIntentsAPIService PaymentIntentsAPI service
type PaymentIntentsAPIService service

type ApiPaymentIntentControllerCreateBankPaymentIntentRequest struct {
	ctx context.Context
	ApiService *PaymentIntentsAPIService
	idempotencyKey *string
	createBankPaymentIntentDto *CreateBankPaymentIntentDto
}

// Unique UUID v4 for idempotent requests. Prevents duplicate payments.
func (r ApiPaymentIntentControllerCreateBankPaymentIntentRequest) IdempotencyKey(idempotencyKey string) ApiPaymentIntentControllerCreateBankPaymentIntentRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Bank payment intent creation data
func (r ApiPaymentIntentControllerCreateBankPaymentIntentRequest) CreateBankPaymentIntentDto(createBankPaymentIntentDto CreateBankPaymentIntentDto) ApiPaymentIntentControllerCreateBankPaymentIntentRequest {
	r.createBankPaymentIntentDto = &createBankPaymentIntentDto
	return r
}

func (r ApiPaymentIntentControllerCreateBankPaymentIntentRequest) Execute() (*http.Response, error) {
	return r.ApiService.PaymentIntentControllerCreateBankPaymentIntentExecute(r)
}

/*
PaymentIntentControllerCreateBankPaymentIntent Create a bank payment intent

Creates a new bank payment intent for fiat-to-stablecoin transfers.
    
This endpoint allows you to create payment intents for bank transfers (ACH, Wire, SEPA) that convert to stablecoins.
Perfect for onboarding users from traditional banking to crypto.

## Supported Payment Rails
- **ACH_PUSH**: US bank transfers (same-day or standard)
- **WIRE**: International wire transfers
- **SEPA**: European bank transfers

## Use Cases
- USD bank account to USDC conversion
- EUR bank account to EURC conversion
- MXN bank account to stablecoin conversion
- Flexible amount payment intents for variable pricing

## Supported Source Currencies
- **USD**: US Dollar
- **EUR**: Euro
- **MXN**: Mexican Peso

## Example: USD Bank to USDC
```json
{
  "sourcePaymentRail": "ach_push",
  "sourceCurrency": "usd",
  "destinationCurrency": "usdc",
  "destinationNetwork": "ethereum",
  "destinationAddress": "0x742d35Cc6634C0532925a3b8D4C9db96c4b4d8e1",
  "amount": "1000.00",
  "customer_first_name": "John",
  "customer_last_name": "Doe",
  "customer_email": "john.doe@example.com",
  "ach_reference": "INV12345"
}
```

## Reference Fields
Use appropriate reference fields based on the payment rail:
- `ach_reference`: For ACH transfers (max 10 chars, alphanumeric + spaces)
- `wire_message`: For wire transfers (max 256 chars)
- `sepa_reference`: For SEPA transfers (6-140 chars, specific character set)

## Idempotency
Include an `idempotency-key` header with a unique UUID v4 to prevent duplicate payments. Subsequent requests with the same key will return the original response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentIntentControllerCreateBankPaymentIntentRequest
*/
func (a *PaymentIntentsAPIService) PaymentIntentControllerCreateBankPaymentIntent(ctx context.Context) ApiPaymentIntentControllerCreateBankPaymentIntentRequest {
	return ApiPaymentIntentControllerCreateBankPaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PaymentIntentsAPIService) PaymentIntentControllerCreateBankPaymentIntentExecute(r ApiPaymentIntentControllerCreateBankPaymentIntentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentIntentsAPIService.PaymentIntentControllerCreateBankPaymentIntent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v0/payment-intents/bank"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createBankPaymentIntentDto == nil {
		return nil, reportError("createBankPaymentIntentDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-key", r.idempotencyKey, "simple", "")
	// body params
	localVarPostBody = r.createBankPaymentIntentDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-secret"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-secret"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPaymentIntentControllerCreateStablePaymentIntentRequest struct {
	ctx context.Context
	ApiService *PaymentIntentsAPIService
	idempotencyKey *string
	createStablePaymentIntentDto *CreateStablePaymentIntentDto
}

// Unique UUID v4 for idempotent requests. Prevents duplicate payments.
func (r ApiPaymentIntentControllerCreateStablePaymentIntentRequest) IdempotencyKey(idempotencyKey string) ApiPaymentIntentControllerCreateStablePaymentIntentRequest {
	r.idempotencyKey = &idempotencyKey
	return r
}

// Stable payment intent creation data
func (r ApiPaymentIntentControllerCreateStablePaymentIntentRequest) CreateStablePaymentIntentDto(createStablePaymentIntentDto CreateStablePaymentIntentDto) ApiPaymentIntentControllerCreateStablePaymentIntentRequest {
	r.createStablePaymentIntentDto = &createStablePaymentIntentDto
	return r
}

func (r ApiPaymentIntentControllerCreateStablePaymentIntentRequest) Execute() (*http.Response, error) {
	return r.ApiService.PaymentIntentControllerCreateStablePaymentIntentExecute(r)
}

/*
PaymentIntentControllerCreateStablePaymentIntent Create a stable payment intent

Creates a new stable payment intent for stablecoin-to-stablecoin transfers.
    
This endpoint allows you to create payment intents for transfers between different stablecoins and networks.
Perfect for cross-chain stablecoin swaps and conversions.

## Use Cases
- USDC to EURC conversions
- Cross-chain stablecoin transfers (e.g., Ethereum USDC to Polygon USDC)
- Flexible amount payment intents for dynamic pricing

## Example: USDC to EURC Conversion
```json
{
  "sourceCurrency": "usdc",
  "sourceNetwork": "ethereum",
  "destinationCurrency": "eurc",
  "destinationNetwork": "polygon",
  "destinationAddress": "0x742d35Cc6634C0532925a3b8D4C9db96c4b4d8e1",
  "amount": "100.00",
  "customer_first_name": "John",
  "customer_last_name": "Doe",
  "customer_email": "john.doe@example.com"
}
```

## Flexible Amount Payments
Omit the `amount` field to create a flexible payment intent where users can specify the amount during payment.

## Idempotency
Include an `idempotency-key` header with a unique UUID v4 to prevent duplicate payments. Subsequent requests with the same key will return the original response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaymentIntentControllerCreateStablePaymentIntentRequest
*/
func (a *PaymentIntentsAPIService) PaymentIntentControllerCreateStablePaymentIntent(ctx context.Context) ApiPaymentIntentControllerCreateStablePaymentIntentRequest {
	return ApiPaymentIntentControllerCreateStablePaymentIntentRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *PaymentIntentsAPIService) PaymentIntentControllerCreateStablePaymentIntentExecute(r ApiPaymentIntentControllerCreateStablePaymentIntentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentIntentsAPIService.PaymentIntentControllerCreateStablePaymentIntent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v0/payment-intents/stablecoin"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.idempotencyKey == nil {
		return nil, reportError("idempotencyKey is required and must be specified")
	}
	if r.createStablePaymentIntentDto == nil {
		return nil, reportError("createStablePaymentIntentDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "idempotency-key", r.idempotencyKey, "simple", "")
	// body params
	localVarPostBody = r.createStablePaymentIntentDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-secret"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-secret"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["x-client-key"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["x-client-key"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
